(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{348:function(e,t,s){"use strict";s.r(t);var o=s(1),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"consensus-reactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consensus-reactor"}}),e._v(" Consensus Reactor")]),e._v(" "),s("p",[e._v("Consensus Reactor defines a reactor for the consensus service. It contains the ConsensusState service that\nmanages the state of the Tendermint consensus internal state machine.\nWhen Consensus Reactor is started, it starts Broadcast Routine which starts ConsensusState service.\nFurthermore, for each peer that is added to the Consensus Reactor, it creates (and manages) the known peer state\n(that is used extensively in gossip routines) and starts the following three routines for the peer p:\nGossip Data Routine, Gossip Votes Routine and QueryMaj23Routine. Finally, Consensus Reactor is responsible\nfor decoding messages received from a peer and for adequate processing of the message depending on its type and content.\nThe processing normally consists of updating the known peer state and for some messages\n("),s("code",[e._v("ProposalMessage")]),e._v(", "),s("code",[e._v("BlockPartMessage")]),e._v(" and "),s("code",[e._v("VoteMessage")]),e._v(") also forwarding message to ConsensusState module\nfor further processing. In the following text we specify the core functionality of those separate unit of executions\nthat are part of the Consensus Reactor.")]),e._v(" "),s("h2",{attrs:{id:"consensusstate-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consensusstate-service"}}),e._v(" ConsensusState service")]),e._v(" "),s("p",[e._v("Consensus State handles execution of the Tendermint BFT consensus algorithm. It processes votes and proposals,\nand upon reaching agreement, commits blocks to the chain and executes them against the application.\nThe internal state machine receives input from peers, the internal validator and from a timer.")]),e._v(" "),s("p",[e._v("Inside Consensus State we have the following units of execution: Timeout Ticker and Receive Routine.\nTimeout Ticker is a timer that schedules timeouts conditional on the height/round/step that are processed\nby the Receive Routine.")]),e._v(" "),s("h3",{attrs:{id:"receive-routine-of-the-consensusstate-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#receive-routine-of-the-consensusstate-service"}}),e._v(" Receive Routine of the ConsensusState service")]),e._v(" "),s("p",[e._v("Receive Routine of the ConsensusState handles messages which may cause internal consensus state transitions.\nIt is the only routine that updates RoundState that contains internal consensus state.\nUpdates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.\nIt receives messages from peers, internal validators and from Timeout Ticker\nand invokes the corresponding handlers, potentially updating the RoundState.\nThe details of the protocol (together with formal proofs of correctness) implemented by the Receive Routine are\ndiscussed in separate document. For understanding of this document\nit is sufficient to understand that the Receive Routine manages and updates RoundState data structure that is\nthen extensively used by the gossip routines to determine what information should be sent to peer processes.")]),e._v(" "),s("h2",{attrs:{id:"round-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#round-state"}}),e._v(" Round State")]),e._v(" "),s("p",[e._v("RoundState defines the internal consensus state. It contains height, round, round step, a current validator set,\na proposal and proposal block for the current round, locked round and block (if some block is being locked), set of\nreceived votes and last commit and last validators set.")]),e._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type RoundState struct {\n\tHeight             int64\n\tRound              int\n\tStep               RoundStepType\n\tValidators         ValidatorSet\n\tProposal           Proposal\n\tProposalBlock      Block\n\tProposalBlockParts PartSet\n\tLockedRound        int\n\tLockedBlock        Block\n\tLockedBlockParts   PartSet\n\tVotes              HeightVoteSet\n\tLastCommit         VoteSet\n\tLastValidators     ValidatorSet\n}\n")])])]),s("p",[e._v("Internally, consensus will run as a state machine with the following states:")]),e._v(" "),s("ul",[s("li",[e._v("RoundStepNewHeight")]),e._v(" "),s("li",[e._v("RoundStepNewRound")]),e._v(" "),s("li",[e._v("RoundStepPropose")]),e._v(" "),s("li",[e._v("RoundStepProposeWait")]),e._v(" "),s("li",[e._v("RoundStepPrevote")]),e._v(" "),s("li",[e._v("RoundStepPrevoteWait")]),e._v(" "),s("li",[e._v("RoundStepPrecommit")]),e._v(" "),s("li",[e._v("RoundStepPrecommitWait")]),e._v(" "),s("li",[e._v("RoundStepCommit")])]),e._v(" "),s("h2",{attrs:{id:"peer-round-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#peer-round-state"}}),e._v(" Peer Round State")]),e._v(" "),s("p",[e._v("Peer round state contains the known state of a peer. It is being updated by the Receive routine of\nConsensus Reactor and by the gossip routines upon sending a message to the peer.")]),e._v(" "),s("div",{staticClass:"language-golang extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("type PeerRoundState struct {\n\tHeight                   int64               // Height peer is at\n\tRound                    int                 // Round peer is at, -1 if unknown.\n\tStep                     RoundStepType       // Step peer is at\n\tProposal                 bool                // True if peer has proposal for this round\n\tProposalBlockPartsHeader PartSetHeader\n\tProposalBlockParts       BitArray\n\tProposalPOLRound         int                 // Proposal's POL round. -1 if none.\n\tProposalPOL              BitArray            // nil until ProposalPOLMessage received.\n\tPrevotes                 BitArray            // All votes peer has for this round\n\tPrecommits               BitArray            // All precommits peer has for this round\n\tLastCommitRound          int                 // Round of commit for last height. -1 if none.\n\tLastCommit               BitArray            // All commit precommits of commit for last height.\n\tCatchupCommitRound       int                 // Round that we have commit for. Not necessarily unique. -1 if none.\n\tCatchupCommit            BitArray            // All commit precommits peer has for this height & CatchupCommitRound\n}\n")])])]),s("h2",{attrs:{id:"receive-method-of-consensus-reactor"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#receive-method-of-consensus-reactor"}}),e._v(" Receive method of Consensus reactor")]),e._v(" "),s("p",[e._v("The entry point of the Consensus reactor is a receive method. When a message is\nreceived from a peer p, normally the peer round state is updated\ncorrespondingly, and some messages are passed for further processing, for\nexample to ConsensusState service. We now specify the processing of messages in\nthe receive method of Consensus reactor for each message type. In the following\nmessage handler, "),s("code",[e._v("rs")]),e._v(" and "),s("code",[e._v("prs")]),e._v(" denote "),s("code",[e._v("RoundState")]),e._v(" and "),s("code",[e._v("PeerRoundState")]),e._v(",\nrespectively.")]),e._v(" "),s("h3",{attrs:{id:"newroundstepmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#newroundstepmessage-handler"}}),e._v(" NewRoundStepMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if msg is from smaller height/round/step then return\n    // Just remember these values.\n    prsHeight = prs.Height\n    prsRound = prs.Round\n    prsCatchupCommitRound = prs.CatchupCommitRound\n    prsCatchupCommit = prs.CatchupCommit\n\n    Update prs with values from msg\n    if prs.Height or prs.Round has been updated then\n        reset Proposal related fields of the peer state\n    if prs.Round has been updated and msg.Round == prsCatchupCommitRound then\n        prs.Precommits = psCatchupCommit\n    if prs.Height has been updated then\n        if prsHeight+1 == msg.Height && prsRound == msg.LastCommitRound then\n            prs.LastCommitRound = msg.LastCommitRound\n        \tprs.LastCommit = prs.Precommits\n        } else {\n            prs.LastCommitRound = msg.LastCommitRound\n        \tprs.LastCommit = nil\n        }\n        Reset prs.CatchupCommitRound and prs.CatchupCommit\n")])])]),s("h3",{attrs:{id:"newvalidblockmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#newvalidblockmessage-handler"}}),e._v(" NewValidBlockMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height != msg.Height then return\n\n    if prs.Round != msg.Round && !msg.IsCommit then return\n\n    prs.ProposalBlockPartsHeader = msg.BlockPartsHeader\n    prs.ProposalBlockParts = msg.BlockParts\n")])])]),s("p",[e._v("The number of block parts is limited to 1601 ("),s("code",[e._v("types.MaxBlockPartsCount")]),e._v(") to\nprotect the node against DOS attacks.")]),e._v(" "),s("h3",{attrs:{id:"hasvotemessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hasvotemessage-handler"}}),e._v(" HasVoteMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height == msg.Height then\n        prs.setHasVote(msg.Height, msg.Round, msg.Type, msg.Index)\n")])])]),s("h3",{attrs:{id:"votesetmaj23message-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#votesetmaj23message-handler"}}),e._v(" VoteSetMaj23Message handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height == msg.Height then\n        Record in rs that a peer claim to have ⅔ majority for msg.BlockID\n        Send VoteSetBitsMessage showing votes node has for that BlockId\n")])])]),s("h3",{attrs:{id:"proposalmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proposalmessage-handler"}}),e._v(" ProposalMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height != msg.Height || prs.Round != msg.Round || prs.Proposal then return\n    prs.Proposal = true\n    if prs.ProposalBlockParts == empty set then // otherwise it is set in NewValidBlockMessage handler\n      prs.ProposalBlockPartsHeader = msg.BlockPartsHeader\n    prs.ProposalPOLRound = msg.POLRound\n    prs.ProposalPOL = nil\n    Send msg through internal peerMsgQueue to ConsensusState service\n")])])]),s("h3",{attrs:{id:"proposalpolmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proposalpolmessage-handler"}}),e._v(" ProposalPOLMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height != msg.Height or prs.ProposalPOLRound != msg.ProposalPOLRound then return\n    prs.ProposalPOL = msg.ProposalPOL\n")])])]),s("p",[e._v("The number of votes is limited to 10000 ("),s("code",[e._v("types.MaxVotesCount")]),e._v(") to protect the\nnode against DOS attacks.")]),e._v(" "),s("h3",{attrs:{id:"blockpartmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blockpartmessage-handler"}}),e._v(" BlockPartMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    if prs.Height != msg.Height || prs.Round != msg.Round then return\n    Record in prs that peer has block part msg.Part.Index\n    Send msg trough internal peerMsgQueue to ConsensusState service\n")])])]),s("h3",{attrs:{id:"votemessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#votemessage-handler"}}),e._v(" VoteMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    Record in prs that a peer knows vote with index msg.vote.ValidatorIndex for particular height and round\n    Send msg trough internal peerMsgQueue to ConsensusState service\n")])])]),s("h3",{attrs:{id:"votesetbitsmessage-handler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#votesetbitsmessage-handler"}}),e._v(" VoteSetBitsMessage handler")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("handleMessage(msg):\n    Update prs for the bit-array of votes peer claims to have for the msg.BlockID\n")])])]),s("p",[e._v("The number of votes is limited to 10000 ("),s("code",[e._v("types.MaxVotesCount")]),e._v(") to protect the\nnode against DOS attacks.")]),e._v(" "),s("h2",{attrs:{id:"gossip-data-routine"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gossip-data-routine"}}),e._v(" Gossip Data Routine")]),e._v(" "),s("p",[e._v("It is used to send the following messages to the peer: "),s("code",[e._v("BlockPartMessage")]),e._v(", "),s("code",[e._v("ProposalMessage")]),e._v(" and\n"),s("code",[e._v("ProposalPOLMessage")]),e._v(" on the DataChannel. The gossip data routine is based on the local RoundState ("),s("code",[e._v("rs")]),e._v(")\nand the known PeerRoundState ("),s("code",[e._v("prs")]),e._v("). The routine repeats forever the logic shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1a) if rs.ProposalBlockPartsHeader == prs.ProposalBlockPartsHeader and the peer does not have all the proposal parts then\n        Part = pick a random proposal block part the peer does not have\n        Send BlockPartMessage(rs.Height, rs.Round, Part) to the peer on the DataChannel\n        if send returns true, record that the peer knows the corresponding block Part\n\t    Continue\n\n1b) if (0 < prs.Height) and (prs.Height < rs.Height) then\n        help peer catch up using gossipDataForCatchup function\n        Continue\n\n1c) if (rs.Height != prs.Height) or (rs.Round != prs.Round) then\n        Sleep PeerGossipSleepDuration\n        Continue\n\n//  at this point rs.Height == prs.Height and rs.Round == prs.Round\n1d) if (rs.Proposal != nil and !prs.Proposal) then\n        Send ProposalMessage(rs.Proposal) to the peer\n        if send returns true, record that the peer knows Proposal\n\t    if 0 <= rs.Proposal.POLRound then\n\t    polRound = rs.Proposal.POLRound\n        prevotesBitArray = rs.Votes.Prevotes(polRound).BitArray()\n        Send ProposalPOLMessage(rs.Height, polRound, prevotesBitArray)\n        Continue\n\n2)  Sleep PeerGossipSleepDuration\n")])])]),s("h3",{attrs:{id:"gossip-data-for-catchup"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gossip-data-for-catchup"}}),e._v(" Gossip Data For Catchup")]),e._v(" "),s("p",[e._v("This function is responsible for helping peer catch up if it is at the smaller height (prs.Height < rs.Height).\nThe function executes the following logic:")]),e._v(" "),s("pre",[s("code",[e._v("if peer does not have all block parts for prs.ProposalBlockPart then\n    blockMeta =  Load Block Metadata for height prs.Height from blockStore\n    if (!blockMeta.BlockID.PartsHeader == prs.ProposalBlockPartsHeader) then\n        Sleep PeerGossipSleepDuration\n\treturn\n    Part = pick a random proposal block part the peer does not have\n    Send BlockPartMessage(prs.Height, prs.Round, Part) to the peer on the DataChannel\n    if send returns true, record that the peer knows the corresponding block Part\n    return\nelse Sleep PeerGossipSleepDuration\n")])]),e._v(" "),s("h2",{attrs:{id:"gossip-votes-routine"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gossip-votes-routine"}}),e._v(" Gossip Votes Routine")]),e._v(" "),s("p",[e._v("It is used to send the following message: "),s("code",[e._v("VoteMessage")]),e._v(" on the VoteChannel.\nThe gossip votes routine is based on the local RoundState ("),s("code",[e._v("rs")]),e._v(")\nand the known PeerRoundState ("),s("code",[e._v("prs")]),e._v("). The routine repeats forever the logic shown below:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1a) if rs.Height == prs.Height then\n        if prs.Step == RoundStepNewHeight then\n            vote = random vote from rs.LastCommit the peer does not have\n            Send VoteMessage(vote) to the peer\n            if send returns true, continue\n\n        if prs.Step <= RoundStepPrevote and prs.Round != -1 and prs.Round <= rs.Round then\n            Prevotes = rs.Votes.Prevotes(prs.Round)\n            vote = random vote from Prevotes the peer does not have\n            Send VoteMessage(vote) to the peer\n            if send returns true, continue\n\n        if prs.Step <= RoundStepPrecommit and prs.Round != -1 and prs.Round <= rs.Round then\n     \t    Precommits = rs.Votes.Precommits(prs.Round)\n            vote = random vote from Precommits the peer does not have\n            Send VoteMessage(vote) to the peer\n            if send returns true, continue\n\n        if prs.ProposalPOLRound != -1 then\n            PolPrevotes = rs.Votes.Prevotes(prs.ProposalPOLRound)\n            vote = random vote from PolPrevotes the peer does not have\n            Send VoteMessage(vote) to the peer\n            if send returns true, continue\n\n1b)  if prs.Height != 0 and rs.Height == prs.Height+1 then\n        vote = random vote from rs.LastCommit peer does not have\n        Send VoteMessage(vote) to the peer\n        if send returns true, continue\n\n1c)  if prs.Height != 0 and rs.Height >= prs.Height+2 then\n        Commit = get commit from BlockStore for prs.Height\n        vote = random vote from Commit the peer does not have\n        Send VoteMessage(vote) to the peer\n        if send returns true, continue\n\n2)   Sleep PeerGossipSleepDuration\n")])])]),s("h2",{attrs:{id:"querymaj23routine"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#querymaj23routine"}}),e._v(" QueryMaj23Routine")]),e._v(" "),s("p",[e._v("It is used to send the following message: "),s("code",[e._v("VoteSetMaj23Message")]),e._v(". "),s("code",[e._v("VoteSetMaj23Message")]),e._v(" is sent to indicate that a given\nBlockID has seen +2/3 votes. This routine is based on the local RoundState ("),s("code",[e._v("rs")]),e._v(") and the known PeerRoundState\n("),s("code",[e._v("prs")]),e._v("). The routine repeats forever the logic shown below.")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("1a) if rs.Height == prs.Height then\n        Prevotes = rs.Votes.Prevotes(prs.Round)\n        if there is a ⅔ majority for some blockId in Prevotes then\n        m = VoteSetMaj23Message(prs.Height, prs.Round, Prevote, blockId)\n        Send m to peer\n        Sleep PeerQueryMaj23SleepDuration\n\n1b) if rs.Height == prs.Height then\n        Precommits = rs.Votes.Precommits(prs.Round)\n        if there is a ⅔ majority for some blockId in Precommits then\n        m = VoteSetMaj23Message(prs.Height,prs.Round,Precommit,blockId)\n        Send m to peer\n        Sleep PeerQueryMaj23SleepDuration\n\n1c) if rs.Height == prs.Height and prs.ProposalPOLRound >= 0 then\n        Prevotes = rs.Votes.Prevotes(prs.ProposalPOLRound)\n        if there is a ⅔ majority for some blockId in Prevotes then\n        m = VoteSetMaj23Message(prs.Height,prs.ProposalPOLRound,Prevotes,blockId)\n        Send m to peer\n        Sleep PeerQueryMaj23SleepDuration\n\n1d) if prs.CatchupCommitRound != -1 and 0 < prs.Height and\n        prs.Height <= blockStore.Height() then\n        Commit = LoadCommit(prs.Height)\n        m = VoteSetMaj23Message(prs.Height,Commit.Round,Precommit,Commit.blockId)\n        Send m to peer\n        Sleep PeerQueryMaj23SleepDuration\n\n2)  Sleep PeerQueryMaj23SleepDuration\n")])])]),s("h2",{attrs:{id:"broadcast-routine"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#broadcast-routine"}}),e._v(" Broadcast routine")]),e._v(" "),s("p",[e._v("The Broadcast routine subscribes to an internal event bus to receive new round steps and votes messages, and broadcasts messages to peers upon receiving those\nevents.\nIt broadcasts "),s("code",[e._v("NewRoundStepMessage")]),e._v(" or "),s("code",[e._v("CommitStepMessage")]),e._v(" upon new round state event. Note that\nbroadcasting these messages does not depend on the PeerRoundState; it is sent on the StateChannel.\nUpon receiving VoteMessage it broadcasts "),s("code",[e._v("HasVoteMessage")]),e._v(" message to its peers on the StateChannel.")]),e._v(" "),s("h2",{attrs:{id:"channels"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#channels"}}),e._v(" Channels")]),e._v(" "),s("p",[e._v("Defines 4 channels: state, data, vote and vote_set_bits. Each channel\nhas "),s("code",[e._v("SendQueueCapacity")]),e._v(" and "),s("code",[e._v("RecvBufferCapacity")]),e._v(" and\n"),s("code",[e._v("RecvMessageCapacity")]),e._v(" set to "),s("code",[e._v("maxMsgSize")]),e._v(".")]),e._v(" "),s("p",[e._v("Sending incorrectly encoded data will result in stopping the peer.")])])}),[],!1,null,null,null);t.default=a.exports}}]);