(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{419:function(t,a,s){"use strict";s.r(a);var e=s(1),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"blockchain"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blockchain"}}),t._v(" Blockchain")]),t._v(" "),s("p",[t._v("Here we describe the data structures in the Tendermint blockchain and the rules for validating them.")]),t._v(" "),s("h2",{attrs:{id:"data-structures"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-structures"}}),t._v(" Data Structures")]),t._v(" "),s("p",[t._v("The Tendermint blockchains consists of a short list of basic data types:")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Block")])]),t._v(" "),s("li",[s("code",[t._v("Header")])]),t._v(" "),s("li",[s("code",[t._v("Version")])]),t._v(" "),s("li",[s("code",[t._v("BlockID")])]),t._v(" "),s("li",[s("code",[t._v("Time")])]),t._v(" "),s("li",[s("code",[t._v("Data")]),t._v(" (for transactions)")]),t._v(" "),s("li",[s("code",[t._v("Commit")]),t._v(" and "),s("code",[t._v("Vote")])]),t._v(" "),s("li",[s("code",[t._v("EvidenceData")]),t._v(" and "),s("code",[t._v("Evidence")])])]),t._v(" "),s("h2",{attrs:{id:"block"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#block"}}),t._v(" Block")]),t._v(" "),s("p",[t._v("A block consists of a header, transactions, votes (the commit),\nand a list of evidence of malfeasance (ie. signing conflicting votes).")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Block "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Header      Header\n    Txs         Data\n    Evidence    EvidenceData\n    LastCommit  Commit\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Note the "),s("code",[t._v("LastCommit")]),t._v(" is the set of  votes that committed the last block.")]),t._v(" "),s("h2",{attrs:{id:"header"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#header"}}),t._v(" Header")]),t._v(" "),s("p",[t._v("A block header contains metadata about the block and about the consensus, as well as commitments to\nthe data in the current block, the previous block, and the results returned by the application:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Header "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// basic block info")]),t._v("\n\tVersion  Version\n\tChainID  "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n\tHeight   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n\tTime     Time\n\tNumTxs   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n\tTotalTxs "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// prev block info")]),t._v("\n\tLastBlockID BlockID\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// hashes of block data")]),t._v("\n\tLastCommitHash "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// commit from validators from the last block")]),t._v("\n\tDataHash       "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// MerkleRoot of transaction hashes")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// hashes from the app output from the prev block")]),t._v("\n\tValidatorsHash     "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// validators for the current block")]),t._v("\n\tNextValidatorsHash "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// validators for the next block")]),t._v("\n\tConsensusHash      "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// consensus params for current block")]),t._v("\n\tAppHash            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// state after txs from the previous block")]),t._v("\n\tLastResultsHash    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// root hash of all results from the txs from the previous block")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// consensus info")]),t._v("\n\tEvidenceHash    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// evidence included in the block")]),t._v("\n\tProposerAddress "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// original proposer of the block")]),t._v("\n")])])]),s("p",[t._v("Further details on each of these fields is described below.")]),t._v(" "),s("h2",{attrs:{id:"version"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#version"}}),t._v(" Version")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("Version")]),t._v(" contains the protocol version for the blockchain and the\napplication as two "),s("code",[t._v("uint64")]),t._v(" values:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Version "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Block   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint64")]),t._v("\n    App     "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint64")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("h2",{attrs:{id:"blockid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#blockid"}}),t._v(" BlockID")]),t._v(" "),s("p",[t._v("The "),s("code",[t._v("BlockID")]),t._v(" contains two distinct Merkle roots of the block.\nThe first, used as the block's main hash, is the MerkleRoot\nof all the fields in the header (ie. "),s("code",[t._v("MerkleRoot(header)")]),t._v(".\nThe second, used for secure gossipping of the block during consensus,\nis the MerkleRoot of the complete serialized block\ncut into parts (ie. "),s("code",[t._v("MerkleRoot(MakeParts(block))")]),t._v(").\nThe "),s("code",[t._v("BlockID")]),t._v(" includes these two hashes, as well as the number of\nparts (ie. "),s("code",[t._v("len(MakeParts(block))")]),t._v(")")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" BlockID "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Hash "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n    PartsHeader PartSetHeader\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" PartSetHeader "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Total "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int32")]),t._v("\n    Hash "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("See "),s("router-link",{attrs:{to:"/spec/blockchain/encoding.html#MerkleRoot"}},[t._v("MerkleRoot")]),t._v(" for details.")],1),t._v(" "),s("h2",{attrs:{id:"time"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#time"}}),t._v(" Time")]),t._v(" "),s("p",[t._v("Tendermint uses the\n"),s("a",{attrs:{href:"https://developers.google.com/protocol-buffers/docs/reference/csharp/class/google/protobuf/well-known-types/timestamp",target:"_blank",rel:"noopener noreferrer"}},[t._v("Google.Protobuf.WellKnownTypes.Timestamp"),s("OutboundLink")],1),t._v("\nformat, which uses two integers, one for Seconds and for Nanoseconds.")]),t._v(" "),s("h2",{attrs:{id:"data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data"}}),t._v(" Data")]),t._v(" "),s("p",[t._v("Data is just a wrapper for a list of transactions, where transactions are\narbitrary byte arrays:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type Data struct {\n    Txs [][]byte\n}\n")])])]),s("h2",{attrs:{id:"commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commit"}}),t._v(" Commit")]),t._v(" "),s("p",[t._v("Commit is a simple wrapper for a list of votes, with one vote for each\nvalidator. It also contains the relevant BlockID:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type Commit struct {\n    BlockID     BlockID\n    Precommits  []Vote\n}\n")])])]),s("p",[t._v("NOTE: this will likely change to reduce the commit size by eliminating redundant\ninformation - see "),s("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/1648",target:"_blank",rel:"noopener noreferrer"}},[t._v("issue #1648"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"vote"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vote"}}),t._v(" Vote")]),t._v(" "),s("p",[t._v("A vote is a signed message from a validator for a particular block.\nThe vote includes information about the validator signing it.")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Vote "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tType             "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\tHeight           "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n\tRound            "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\tBlockID          BlockID\n\tTimestamp        Time\n\tValidatorAddress "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\tValidatorIndex   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int")]),t._v("\n\tSignature        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("There are two types of votes:\na "),s("em",[t._v("prevote")]),t._v(" has "),s("code",[t._v("vote.Type == 1")]),t._v(" and\na "),s("em",[t._v("precommit")]),t._v(" has "),s("code",[t._v("vote.Type == 2")]),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"signature"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#signature"}}),t._v(" Signature")]),t._v(" "),s("p",[t._v("Signatures in Tendermint are raw bytes representing the underlying signature.")]),t._v(" "),s("p",[t._v("See the "),s("router-link",{attrs:{to:"/spec/blockchain/encoding.html#key-types"}},[t._v("signature spec")]),t._v(" for more.")],1),t._v(" "),s("h2",{attrs:{id:"evidencedata"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evidencedata"}}),t._v(" EvidenceData")]),t._v(" "),s("p",[t._v("EvidenceData is a simple wrapper for a list of evidence:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("type EvidenceData struct {\n    Evidence []Evidence\n}\n")])])]),s("h2",{attrs:{id:"evidence"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evidence"}}),t._v(" Evidence")]),t._v(" "),s("p",[t._v("Evidence in Tendermint is implemented as an interface.\nThis means any evidence is encoded using its Amino prefix.\nThere is currently only a single type, the "),s("code",[t._v("DuplicateVoteEvidence")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('// amino name: "tendermint/DuplicateVoteEvidence"\ntype DuplicateVoteEvidence struct {\n\tPubKey PubKey\n\tVoteA  Vote\n\tVoteB  Vote\n}\n')])])]),s("p",[t._v("See the "),s("router-link",{attrs:{to:"/spec/blockchain/encoding.html#key-types"}},[t._v("pubkey spec")]),t._v(" for more.")],1),t._v(" "),s("h2",{attrs:{id:"validation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#validation"}}),t._v(" Validation")]),t._v(" "),s("p",[t._v("Here we describe the validation rules for every element in a block.\nBlocks which do not satisfy these rules are considered invalid.")]),t._v(" "),s("p",[t._v("We abuse notation by using something that looks like Go, supplemented with English.\nA statement such as "),s("code",[t._v("x == y")]),t._v(" is an assertion - if it fails, the item is invalid.")]),t._v(" "),s("p",[t._v("We refer to certain globally available objects:\n"),s("code",[t._v("block")]),t._v(" is the block under consideration,\n"),s("code",[t._v("prevBlock")]),t._v(" is the "),s("code",[t._v("block")]),t._v(" at the previous height,\nand "),s("code",[t._v("state")]),t._v(" keeps track of the validator set, the consensus parameters\nand other results from the application. At the point when "),s("code",[t._v("block")]),t._v(" is the block under consideration,\nthe current version of the "),s("code",[t._v("state")]),t._v(" corresponds to the state\nafter executing transactions from the "),s("code",[t._v("prevBlock")]),t._v(".\nElements of an object are accessed as expected,\nie. "),s("code",[t._v("block.Header")]),t._v(".\nSee the "),s("router-link",{attrs:{to:"/spec/blockchain/state.html"}},[t._v("definition of "),s("code",[t._v("State")])]),t._v(".")],1),t._v(" "),s("h3",{attrs:{id:"header-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#header-2"}}),t._v(" Header")]),t._v(" "),s("p",[t._v("A Header is valid if its corresponding fields are valid.")]),t._v(" "),s("h3",{attrs:{id:"version-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#version-2"}}),t._v(" Version")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("block.Version.Block == state.Version.Block\nblock.Version.App == state.Version.App\n")])])]),s("p",[t._v("The block version must match the state version.")]),t._v(" "),s("h3",{attrs:{id:"chainid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chainid"}}),t._v(" ChainID")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("len(block.ChainID) < 50\n")])])]),s("p",[t._v("ChainID must be less than 50 bytes.")]),t._v(" "),s("h3",{attrs:{id:"height"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#height"}}),t._v(" Height")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\nblock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" prevBlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n")])])]),s("p",[t._v("The height is an incrementing integer. The first block has "),s("code",[t._v("block.Header.Height == 1")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"time-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#time-2"}}),t._v(" Time")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("block.Header.Timestamp >= prevBlock.Header.Timestamp + state.consensusParams.Block.TimeIotaMs\nblock.Header.Timestamp == MedianTime(block.LastCommit, state.LastValidators)\n")])])]),s("p",[t._v("The block timestamp must be monotonic.\nIt must equal the weighted median of the timestamps of the valid votes in the block.LastCommit.")]),t._v(" "),s("p",[t._v("Note: the timestamp of a vote must be greater by at least one millisecond than that of the\nblock being voted on.")]),t._v(" "),s("p",[t._v("The timestamp of the first block must be equal to the genesis time (since\nthere's no votes to compute the median).")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("if block.Header.Height == 1 {\n    block.Header.Timestamp == genesisTime\n}\n")])])]),s("p",[t._v("See the section on "),s("router-link",{attrs:{to:"/spec/consensus/bft-time.html"}},[t._v("BFT time")]),t._v(" for more details.")],1),t._v(" "),s("h3",{attrs:{id:"numtxs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#numtxs"}}),t._v(" NumTxs")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NumTxs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Txs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Txs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Number of transactions included in the block.")]),t._v(" "),s("h3",{attrs:{id:"totaltxs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#totaltxs"}}),t._v(" TotalTxs")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("TotalTxs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" prevBlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("TotalTxs "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NumTxs\n")])])]),s("p",[t._v("The cumulative sum of all transactions included in this blockchain.")]),t._v(" "),s("p",[t._v("The first block has "),s("code",[t._v("block.Header.TotalTxs = block.Header.NumberTxs")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"lastblockid"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lastblockid"}}),t._v(" LastBlockID")]),t._v(" "),s("p",[t._v("LastBlockID is the previous block's BlockID:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("prevBlockParts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MakeParts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevBlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nblock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastBlockID "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" BlockID "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevBlock"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    PartsHeader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        Hash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevBlockParts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        Total"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("prevBlockParts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("The first block has "),s("code",[t._v("block.Header.LastBlockID == BlockID{}")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"lastcommithash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lastcommithash"}}),t._v(" LastCommitHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommitHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Precommits"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the votes included in the block.\nThese are the votes that committed the previous block.")]),t._v(" "),s("p",[t._v("The first block has "),s("code",[t._v("block.Header.LastCommitHash == []byte{}")])]),t._v(" "),s("h3",{attrs:{id:"datahash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#datahash"}}),t._v(" DataHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("DataHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Hashes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Txs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Txs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the hashes of transactions included in the block.")]),t._v(" "),s("p",[t._v("Note the transactions are hashed before being included in the Merkle tree,\nso the leaves of the Merkle tree are the hashes, not the transactions\nthemselves. This is because transaction hashes are regularly used as identifiers for\ntransactions.")]),t._v(" "),s("h3",{attrs:{id:"validatorshash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#validatorshash"}}),t._v(" ValidatorsHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ValidatorsHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Validators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the current validator set that is committing the block.\nThis can be used to validate the "),s("code",[t._v("LastCommit")]),t._v(" included in the next block.\nNote the validators are sorted by their address before computing the MerkleRoot.")]),t._v(" "),s("h3",{attrs:{id:"nextvalidatorshash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nextvalidatorshash"}}),t._v(" NextValidatorsHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NextValidatorsHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NextValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the next validator set that will be the validator set that commits the next block.\nThis is included so that the current validator set gets a chance to sign the\nnext validator sets Merkle root.\nNote the validators are sorted by their address before computing the MerkleRoot.")]),t._v(" "),s("h3",{attrs:{id:"consensushash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consensushash"}}),t._v(" ConsensusHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ConsensusHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ConsensusParams"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Hash")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Hash of the amino-encoding of a subset of the consensus parameters.")]),t._v(" "),s("h3",{attrs:{id:"apphash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#apphash"}}),t._v(" AppHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("AppHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("AppHash\n")])])]),s("p",[t._v("Arbitrary byte array returned by the application after executing and commiting the previous block. It serves as the basis for validating any merkle proofs that comes from the ABCI application and represents the state of the actual application rather than the state of the blockchain itself.")]),t._v(" "),s("p",[t._v("The first block has "),s("code",[t._v("block.Header.AppHash == []byte{}")]),t._v(".")]),t._v(" "),s("h3",{attrs:{id:"lastresultshash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lastresultshash"}}),t._v(" LastResultsHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ResultsHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastResults"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the results of the transactions in the previous block.")]),t._v(" "),s("p",[t._v("The first block has "),s("code",[t._v("block.Header.ResultsHash == []byte{}")]),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"evidencehash"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evidencehash"}}),t._v(" EvidenceHash")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("EvidenceHash "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MerkleRoot")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Evidence"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("MerkleRoot of the evidence of Byzantine behaviour included in this block.")]),t._v(" "),s("h3",{attrs:{id:"proposeraddress"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#proposeraddress"}}),t._v(" ProposerAddress")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ProposerAddress in state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Validators\n")])])]),s("p",[t._v("Address of the original proposer of the block. Must be a current validator.")]),t._v(" "),s("h2",{attrs:{id:"txs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#txs"}}),t._v(" Txs")]),t._v(" "),s("p",[t._v("Arbitrary length array of arbitrary length byte-arrays.")]),t._v(" "),s("h2",{attrs:{id:"lastcommit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lastcommit"}}),t._v(" LastCommit")]),t._v(" "),s("p",[t._v("The first height is an exception - it requires the LastCommit to be empty:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Header"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("Otherwise, we require:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("len")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\ntalliedVotingPower "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vote "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("range")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" vote "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("continue")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Type "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("\n    vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Height "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Height")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Round "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastCommit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Round")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("BlockID "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastBlockID\n\n    val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Verify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ChainID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PubKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n\n    talliedVotingPower "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" val"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VotingPower\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\ntalliedVotingPower "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("TotalVotingPower")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("LastValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Includes one (possibly nil) vote for every current validator.\nNon-nil votes must be Precommits.\nAll votes must be for the same height and round.\nAll votes must be for the previous block.\nAll votes must have a valid signature from the corresponding validator.\nThe sum total of the voting power of the validators that voted\nmust be greater than 2/3 of the total voting power of the complete validator set.")]),t._v(" "),s("p",[t._v("The number of votes in a commit is limited to 10000 (see "),s("code",[t._v("types.MaxVotesCount")]),t._v(").")]),t._v(" "),s("h3",{attrs:{id:"vote-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vote-2"}}),t._v(" Vote")]),t._v(" "),s("p",[t._v("A vote is a signed message broadcast in the consensus for a particular block at a particular height and round.\nWhen stored in the blockchain or propagated over the network, votes are encoded in Amino.\nFor signing, votes are represented via "),s("code",[t._v("CanonicalVote")]),t._v(" and also encoded using amino (protobuf compatible) via\n"),s("code",[t._v("Vote.SignBytes")]),t._v(" which includes the "),s("code",[t._v("ChainID")]),t._v(", and uses a different ordering of\nthe fields.")]),t._v(" "),s("p",[t._v("We define a method "),s("code",[t._v("Verify")]),t._v(" that returns "),s("code",[t._v("true")]),t._v(" if the signature verifies against the pubkey for the "),s("code",[t._v("SignBytes")]),t._v("\nusing the given ChainID:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vote "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("Vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Verify")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("chainID "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pubKey crypto"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("PubKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("error")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("bytes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Equal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pubKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Address")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ValidatorAddress"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ErrVoteInvalidValidatorAddress\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("pubKey"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("VerifyBytes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("SignBytes")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("chainID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" vote"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Signature"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\t\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" ErrVoteInvalidSignature\n\t"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\t"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("nil")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("where "),s("code",[t._v("pubKey.Verify")]),t._v(" performs the appropriate digital signature verification of the "),s("code",[t._v("pubKey")]),t._v("\nagainst the given signature and message bytes.")]),t._v(" "),s("h2",{attrs:{id:"evidence-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#evidence-2"}}),t._v(" Evidence")]),t._v(" "),s("p",[t._v("There is currently only one kind of evidence, "),s("code",[t._v("DuplicateVoteEvidence")]),t._v(".")]),t._v(" "),s("p",[t._v("DuplicateVoteEvidence "),s("code",[t._v("ev")]),t._v(" is valid if")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("ev.VoteA")]),t._v(" and "),s("code",[t._v("ev.VoteB")]),t._v(" can be verified with "),s("code",[t._v("ev.PubKey")])]),t._v(" "),s("li",[s("code",[t._v("ev.VoteA")]),t._v(" and "),s("code",[t._v("ev.VoteB")]),t._v(" have the same "),s("code",[t._v("Height, Round, Address, Index, Type")])]),t._v(" "),s("li",[s("code",[t._v("ev.VoteA.BlockID != ev.VoteB.BlockID")])]),t._v(" "),s("li",[s("code",[t._v("(block.Height - ev.VoteA.Height) < MAX_EVIDENCE_AGE")])])]),t._v(" "),s("h1",{attrs:{id:"execution"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#execution"}}),t._v(" Execution")]),t._v(" "),s("p",[t._v("Once a block is validated, it can be executed against the state.")]),t._v(" "),s("p",[t._v("The state follows this recursive equation:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" InitialState\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("state")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ABCIApp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("block")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("h"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("where "),s("code",[t._v("InitialState")]),t._v(" includes the initial consensus parameters and validator set,\nand "),s("code",[t._v("ABCIApp")]),t._v(" is an ABCI application that can return results and changes to the validator\nset (TODO). Execute is defined as:")]),t._v(" "),s("div",{staticClass:"language-go extra-class"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("Execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s State"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" app ABCIApp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" block Block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" State "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Fuction ApplyBlock executes block of transactions against the app and returns the new root hash of the app state,")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// modifications to the validator set and the changes of the consensus parameters.")]),t._v("\n    AppHash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ValidatorChanges"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ConsensusParamChanges "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" app"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("ApplyBlock")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("block"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" State"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        LastResults"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" abciResponses"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("DeliverTxResults"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        AppHash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" AppHash"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        LastValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Validators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        Validators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NextValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        NextValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("UpdateValidators")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("NextValidators"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ValidatorChanges"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        ConsensusParams"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("UpdateConsensusParams")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("state"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("ConsensusParams"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" ConsensusParamChanges"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);