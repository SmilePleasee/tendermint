(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{361:function(e,t,a){"use strict";a.r(t);var s=a(1),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"validator-signing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validator-signing"}}),e._v(" Validator Signing")]),e._v(" "),a("p",[e._v("Here we specify the rules for validating a proposal and vote before signing.\nFirst we include some general notes on validating data structures common to both types.\nWe then provide specific validation rules for each. Finally, we include validation rules to prevent double-sigining.")]),e._v(" "),a("h2",{attrs:{id:"signedmsgtype"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signedmsgtype"}}),e._v(" SignedMsgType")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("SignedMsgType")]),e._v(" is a single byte that refers to the type of the message\nbeing signed. It is defined in Go as follows:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// SignedMsgType is a type of signed message in the consensus.\ntype SignedMsgType byte\n\nconst (\n\t// Votes\n\tPrevoteType   SignedMsgType = 0x01\n\tPrecommitType SignedMsgType = 0x02\n\n\t// Proposals\n\tProposalType SignedMsgType = 0x20\n)\n")])])]),a("p",[e._v("All signed messages must correspond to one of these types.")]),e._v(" "),a("h2",{attrs:{id:"timestamp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#timestamp"}}),e._v(" Timestamp")]),e._v(" "),a("p",[e._v("Timestamp validation is subtle and there are currently no bounds placed on the\ntimestamp included in a proposal or vote. It is expected that validators will honestly\nreport their local clock time. The median of all timestamps\nincluded in a commit is used as the timestamp for the next block height.")]),e._v(" "),a("p",[e._v("Timestamps are expected to be strictly monotonic for a given validator, though\nthis is not currently enforced.")]),e._v(" "),a("h2",{attrs:{id:"chainid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chainid"}}),e._v(" ChainID")]),e._v(" "),a("p",[e._v("ChainID is an unstructured string with a max length of 50-bytes.\nIn the future, the ChainID may become structured, and may take on longer lengths.\nFor now, it is recommended that signers be configured for a particular ChainID,\nand to only sign votes and proposals corresponding to that ChainID.")]),e._v(" "),a("h2",{attrs:{id:"blockid"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#blockid"}}),e._v(" BlockID")]),e._v(" "),a("p",[e._v("BlockID is the structure used to represent the block:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type BlockID struct {\n\tHash        []byte\n\tPartsHeader PartSetHeader\n}\n\ntype PartSetHeader struct {\n\tHash  []byte\n\tTotal int\n}\n")])])]),a("p",[e._v("To be included in a valid vote or proposal, BlockID must either represent a "),a("code",[e._v("nil")]),e._v(" block, or a complete one.\nWe introduce two methods, "),a("code",[e._v("BlockID.IsZero()")]),e._v(" and "),a("code",[e._v("BlockID.IsComplete()")]),e._v(" for these cases, respectively.")]),e._v(" "),a("p",[a("code",[e._v("BlockID.IsZero()")]),e._v(" returns true for BlockID "),a("code",[e._v("b")]),e._v(" if each of the following\nare true:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("b.Hash == nil\nb.PartsHeader.Total == 0\nb.PartsHeader.Hash == nil\n")])])]),a("p",[a("code",[e._v("BlockID.IsComplete()")]),e._v(" returns true for BlockID "),a("code",[e._v("b")]),e._v(" if each of the following\nare true:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("len(b.Hash) == 32\nb.PartsHeader.Total > 0\nlen(b.PartsHeader.Hash) == 32\n")])])]),a("h2",{attrs:{id:"proposals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposals"}}),e._v(" Proposals")]),e._v(" "),a("p",[e._v("The structure of a proposal for signing looks like:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('type CanonicalProposal struct {\n\tType      SignedMsgType // type alias for byte\n\tHeight    int64         `binary:"fixed64"`\n\tRound     int64         `binary:"fixed64"`\n\tPOLRound  int64         `binary:"fixed64"`\n\tBlockID   BlockID\n\tTimestamp time.Time\n\tChainID   string\n}\n')])])]),a("p",[e._v("A proposal is valid if each of the following lines evaluates to true for proposal "),a("code",[e._v("p")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("p.Type == 0x20\np.Height > 0\np.Round >= 0\np.POLRound >= -1\np.BlockID.IsComplete()\n")])])]),a("p",[e._v("In other words, a proposal is valid for signing if it contains the type of a Proposal\n(0x20), has a positive, non-zero height, a\nnon-negative round, a POLRound not less than -1, and a complete BlockID.")]),e._v(" "),a("h2",{attrs:{id:"votes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#votes"}}),e._v(" Votes")]),e._v(" "),a("p",[e._v("The structure of a vote for signing looks like:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('type CanonicalVote struct {\n\tType      SignedMsgType // type alias for byte\n\tHeight    int64         `binary:"fixed64"`\n\tRound     int64         `binary:"fixed64"`\n\tBlockID   BlockID\n\tTimestamp time.Time\n\tChainID   string\n}\n')])])]),a("p",[e._v("A vote is valid if each of the following lines evaluates to true for vote "),a("code",[e._v("v")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("v.Type == 0x1 || v.Type == 0x2\nv.Height > 0\nv.Round >= 0\nv.BlockID.IsZero() || v.BlockID.IsComplete()\n")])])]),a("p",[e._v("In other words, a vote is valid for signing if it contains the type of a Prevote\nor Precommit (0x1 or 0x2, respectively), has a positive, non-zero height, a\nnon-negative round, and an empty or valid BlockID.")]),e._v(" "),a("h2",{attrs:{id:"invalid-votes-and-proposals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#invalid-votes-and-proposals"}}),e._v(" Invalid Votes and Proposals")]),e._v(" "),a("p",[e._v("Votes and proposals which do not satisfy the above rules are considered invalid.\nPeers gossipping invalid votes and proposals may be disconnected from other peers on the network.\nNote, however, that there is not currently any explicit mechanism to punish validators signing votes or proposals that fail\nthese basic validation rules.")]),e._v(" "),a("h2",{attrs:{id:"double-signing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#double-signing"}}),e._v(" Double Signing")]),e._v(" "),a("p",[e._v('Signers must be careful not to sign conflicting messages, also known as "double signing" or "equivocating".\nTendermint has mechanisms to publish evidence of validators that signed conflicting votes, so they can be punished\nby the application. Note Tendermint does not currently handle evidence of conflciting proposals, though it may in the future.')]),e._v(" "),a("h3",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}}),e._v(" State")]),e._v(" "),a("p",[e._v("To prevent such double signing, signers must track the height, round, and type of the last message signed.\nAssume the signer keeps the following state, "),a("code",[e._v("s")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("type LastSigned struct {\n\tHeight\tint64\n\tRound\tint64\n\tType\tSignedMsgType // byte\n}\n")])])]),a("p",[e._v("After signing a vote or proposal "),a("code",[e._v("m")]),e._v(", the signer sets:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("s.Height = m.Height\ns.Round = m.Round\ns.Type = m.Type\n")])])]),a("h3",{attrs:{id:"proposals-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposals-2"}}),e._v(" Proposals")]),e._v(" "),a("p",[e._v("A signer should only sign a proposal "),a("code",[e._v("p")]),e._v(" if any of the following lines are true:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("p.Height > s.Height\np.Height == s.Height && p.Round > s.Round\n")])])]),a("p",[e._v("In other words, a proposal should only be signed if it's at a higher height, or a higher round for the same height.\nOnce a proposal or vote has been signed for a given height and round, a proposal should never be signed for the same height and round.")]),e._v(" "),a("h3",{attrs:{id:"votes-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#votes-2"}}),e._v(" Votes")]),e._v(" "),a("p",[e._v("A signer should only sign a vote "),a("code",[e._v("v")]),e._v(" if any of the following lines are true:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("v.Height > s.Height\nv.Height == s.Height && v.Round > s.Round\nv.Height == s.Height && v.Round == s.Round && v.Step == 0x1 && s.Step == 0x20\nv.Height == s.Height && v.Round == s.Round && v.Step == 0x2 && s.Step != 0x2\n")])])]),a("p",[e._v("In other words, a vote should only be signed if it's:")]),e._v(" "),a("ul",[a("li",[e._v("at a higher height")]),e._v(" "),a("li",[e._v("at a higher round for the same height")]),e._v(" "),a("li",[e._v("a prevote for the same height and round where we haven't signed a prevote or precommit (but have signed a proposal)")]),e._v(" "),a("li",[e._v("a precommit for the same height and round where we haven't signed a precommit (but have signed a proposal and/or a prevote)")])]),e._v(" "),a("p",[e._v("This means that once a validator signs a prevote for a given height and round, the only other message it can sign for that height and round is a precommit.\nAnd once a validator signs a precommit for a given height and round, it must not sign any other message for that same height and round.")])])}),[],!1,null,null,null);t.default=n.exports}}]);