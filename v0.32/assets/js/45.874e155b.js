(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{414:function(e,t,n){"use strict";n.r(t);var a=n(1),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"application-development-guide"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#application-development-guide"}}),e._v(" Application Development Guide")]),e._v(" "),n("h2",{attrs:{id:"xxx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#xxx"}}),e._v(" XXX")]),e._v(" "),n("p",[e._v("This page is undergoing deprecation. All content is being moved to the new "),n("router-link",{attrs:{to:"/spec/abci/"}},[e._v("home\nof the ABCI specification")]),e._v(".")],1),e._v(" "),n("h2",{attrs:{id:"abci-design"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abci-design"}}),e._v(" ABCI Design")]),e._v(" "),n("p",[e._v("The purpose of ABCI is to provide a clean interface between state\ntransition machines on one computer and the mechanics of their\nreplication across multiple computers. The former we call 'application\nlogic' and the latter the 'consensus engine'. Application logic\nvalidates transactions and optionally executes transactions against some\npersistent state. A consensus engine ensures all transactions are\nreplicated in the same order on every machine. We call each machine in a\nconsensus engine a 'validator', and each validator runs the same\ntransactions through the same application logic. In particular, we are\ninterested in blockchain-style consensus engines, where transactions are\ncommitted in hash-linked blocks.")]),e._v(" "),n("p",[e._v("The ABCI design has a few distinct components:")]),e._v(" "),n("ul",[n("li",[e._v("message protocol\n"),n("ul",[n("li",[e._v("pairs of request and response messages")]),e._v(" "),n("li",[e._v("consensus makes requests, application responds")]),e._v(" "),n("li",[e._v("defined using protobuf")])])]),e._v(" "),n("li",[e._v("server/client\n"),n("ul",[n("li",[e._v("consensus engine runs the client")]),e._v(" "),n("li",[e._v("application runs the server")]),e._v(" "),n("li",[e._v("two implementations:\n"),n("ul",[n("li",[e._v("async raw bytes")]),e._v(" "),n("li",[e._v("grpc")])])])])]),e._v(" "),n("li",[e._v("blockchain protocol\n"),n("ul",[n("li",[e._v("abci is connection oriented")]),e._v(" "),n("li",[e._v("Tendermint Core maintains three connections:\n"),n("ul",[n("li",[n("a",{attrs:{href:"#mempool-connection"}},[e._v("mempool connection")]),e._v(": for checking if\ntransactions should be relayed before they are committed;\nonly uses "),n("code",[e._v("CheckTx")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#consensus-connection"}},[e._v("consensus connection")]),e._v(": for executing\ntransactions that have been committed. Message sequence is\n-for every block -"),n("code",[e._v("BeginBlock, [DeliverTx, ...], EndBlock, Commit")])]),e._v(" "),n("li",[n("a",{attrs:{href:"#query-connection"}},[e._v("query connection")]),e._v(": for querying the\napplication state; only uses Query and Info")])])])])])]),e._v(" "),n("p",[e._v("The mempool and consensus logic act as clients, and each maintains an\nopen ABCI connection with the application, which hosts an ABCI server.\nShown are the request and response types sent on each connection.")]),e._v(" "),n("p",[e._v("Most of the examples below are from "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/abci/example/kvstore/kvstore.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("kvstore\napplication"),n("OutboundLink")],1),e._v(",\nwhich is a part of the abci repo. "),n("a",{attrs:{href:"https://github.com/tendermint/tendermint/blob/master/abci/example/kvstore/persistent_kvstore.go",target:"_blank",rel:"noopener noreferrer"}},[e._v("persistent_kvstore\napplication"),n("OutboundLink")],1),e._v("\nis used to show "),n("code",[e._v("BeginBlock")]),e._v(", "),n("code",[e._v("EndBlock")]),e._v(" and "),n("code",[e._v("InitChain")]),e._v(" example\nimplementations.")]),e._v(" "),n("h2",{attrs:{id:"blockchain-protocol"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blockchain-protocol"}}),e._v(" Blockchain Protocol")]),e._v(" "),n("p",[e._v("In ABCI, a transaction is simply an arbitrary length byte-array. It is\nthe application's responsibility to define the transaction codec as they\nplease, and to use it for both CheckTx and DeliverTx.")]),e._v(" "),n("p",[e._v("Note that there are two distinct means for running transactions,\ncorresponding to stages of 'awareness' of the transaction in the\nnetwork. The first stage is when a transaction is received by a\nvalidator from a client into the so-called mempool or transaction pool\n-this is where we use CheckTx. The second is when the transaction is\nsuccessfully committed on more than 2/3 of validators - where we use\nDeliverTx. In the former case, it may not be necessary to run all the\nstate transitions associated with the transaction, as the transaction\nmay not ultimately be committed until some much later time, when the\nresult of its execution will be different. For instance, an Ethereum\nABCI app would check signatures and amounts in CheckTx, but would not\nactually execute any contract code until the DeliverTx, so as to avoid\nexecuting state transitions that have not been finalized.")]),e._v(" "),n("p",[e._v("To formalize the distinction further, two explicit ABCI connections are\nmade between Tendermint Core and the application: the mempool connection\nand the consensus connection. We also make a third connection, the query\nconnection, to query the local state of the app.")]),e._v(" "),n("h3",{attrs:{id:"mempool-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#mempool-connection"}}),e._v(" Mempool Connection")]),e._v(" "),n("p",[e._v("The mempool connection is used "),n("em",[e._v("only")]),e._v(" for CheckTx requests. Transactions\nare run using CheckTx in the same order they were received by the\nvalidator. If the CheckTx returns "),n("code",[e._v("OK")]),e._v(", the transaction is kept in\nmemory and relayed to other peers in the same order it was received.\nOtherwise, it is discarded.")]),e._v(" "),n("p",[e._v("CheckTx requests run concurrently with block processing; so they should\nrun against a copy of the main application state which is reset after\nevery block. This copy is necessary to track transitions made by a\nsequence of CheckTx requests before they are included in a block. When a\nblock is committed, the application must ensure to reset the mempool\nstate to the latest committed state. Tendermint Core will then filter\nthrough all transactions in the mempool, removing any that were included\nin the block, and re-run the rest using CheckTx against the post-Commit\nmempool state (this behaviour can be turned off with\n"),n("code",[e._v("[mempool] recheck = false")]),e._v(").")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("func (app *KVStoreApplication) CheckTx(req types.RequestCheckTx) types.ResponseCheckTx {\n\treturn types.ResponseCheckTx{Code: code.CodeTypeOK, GasWanted: 1}\n}\n")])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('ResponseCheckTx requestCheckTx(RequestCheckTx req) {\n    byte[] transaction = req.getTx().toByteArray();\n\n    // validate transaction\n\n    if (notValid) {\n        return ResponseCheckTx.newBuilder().setCode(CodeType.BadNonce).setLog("invalid tx").build();\n    } else {\n        return ResponseCheckTx.newBuilder().setCode(CodeType.OK).build();\n    }\n}\n')])])]),n("h3",{attrs:{id:"replay-protection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#replay-protection"}}),e._v(" Replay Protection")]),e._v(" "),n("p",[e._v("To prevent old transactions from being replayed, CheckTx must implement\nreplay protection.")]),e._v(" "),n("p",[e._v("Tendermint provides the first defence layer by keeping a lightweight\nin-memory cache of 100k ("),n("code",[e._v("[mempool] cache_size")]),e._v(") last transactions in\nthe mempool. If Tendermint is just started or the clients sent more than\n100k transactions, old transactions may be sent to the application. So\nit is important CheckTx implements some logic to handle them.")]),e._v(" "),n("p",[e._v("If there are cases in your application where a transaction may become invalid in some\nfuture state, you probably want to disable Tendermint's\ncache. You can do that by setting "),n("code",[e._v("[mempool] cache_size = 0")]),e._v(" in the\nconfig.")]),e._v(" "),n("h3",{attrs:{id:"consensus-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#consensus-connection"}}),e._v(" Consensus Connection")]),e._v(" "),n("p",[e._v("The consensus connection is used only when a new block is committed, and\ncommunicates all information from the block in a series of requests:\n"),n("code",[e._v("BeginBlock, [DeliverTx, ...], EndBlock, Commit")]),e._v(". That is, when a block\nis committed in the consensus, we send a list of DeliverTx requests (one\nfor each transaction) sandwiched by BeginBlock and EndBlock requests,\nand followed by a Commit.")]),e._v(" "),n("h3",{attrs:{id:"delivertx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#delivertx"}}),e._v(" DeliverTx")]),e._v(" "),n("p",[e._v("DeliverTx is the workhorse of the blockchain. Tendermint sends the\nDeliverTx requests asynchronously but in order, and relies on the\nunderlying socket protocol (ie. TCP) to ensure they are received by the\napp in order. They have already been ordered in the global consensus by\nthe Tendermint protocol.")]),e._v(" "),n("p",[e._v("DeliverTx returns a abci.Result, which includes a Code, Data, and Log.\nThe code may be non-zero (non-OK), meaning the corresponding transaction\nshould have been rejected by the mempool, but may have been included in\na block by a Byzantine proposer.")]),e._v(" "),n("p",[e._v("The block header will be updated (TODO) to include some commitment to\nthe results of DeliverTx, be it a bitarray of non-OK transactions, or a\nmerkle root of the data returned by the DeliverTx requests, or both.")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// tx is either "key=value" or just arbitrary bytes\nfunc (app *KVStoreApplication) DeliverTx(req types.RequestDeliverTx) types.ResponseDeliverTx {\n\tvar key, value []byte\n\tparts := bytes.Split(req.Tx, []byte("="))\n\tif len(parts) == 2 {\n\t\tkey, value = parts[0], parts[1]\n\t} else {\n\t\tkey, value = req.Tx, req.Tx\n\t}\n\n\tapp.state.db.Set(prefixKey(key), value)\n\tapp.state.Size += 1\n\n\tevents := []types.Event{\n\t\t{\n\t\t\tType: "app",\n\t\t\tAttributes: []cmn.KVPair{\n\t\t\t\t{Key: []byte("creator"), Value: []byte("Cosmoshi Netowoko")},\n\t\t\t\t{Key: []byte("key"), Value: key},\n\t\t\t},\n\t\t},\n\t}\n\n\treturn types.ResponseDeliverTx{Code: code.CodeTypeOK, Events: events}\n}\n')])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('/**\n * Using Protobuf types from the protoc compiler, we always start with a byte[]\n */\nResponseDeliverTx deliverTx(RequestDeliverTx request) {\n    byte[] transaction  = request.getTx().toByteArray();\n\n    // validate your transaction\n\n    if (notValid) {\n        return ResponseDeliverTx.newBuilder().setCode(CodeType.BadNonce).setLog("transaction was invalid").build();\n    } else {\n        ResponseDeliverTx.newBuilder().setCode(CodeType.OK).build();\n    }\n\n}\n')])])]),n("h3",{attrs:{id:"commit"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#commit"}}),e._v(" Commit")]),e._v(" "),n("p",[e._v("Once all processing of the block is complete, Tendermint sends the\nCommit request and blocks waiting for a response. While the mempool may\nrun concurrently with block processing (the BeginBlock, DeliverTxs, and\nEndBlock), it is locked for the Commit request so that its state can be\nsafely updated during Commit. This means the app "),n("em",[e._v("MUST NOT")]),e._v(" do any\nblocking communication with the mempool (ie. broadcast_tx) during\nCommit, or there will be deadlock. Note also that all remaining\ntransactions in the mempool are replayed on the mempool connection\n(CheckTx) following a commit.")]),e._v(" "),n("p",[e._v("The app should respond to the Commit request with a byte array, which is\nthe deterministic state root of the application. It is included in the\nheader of the next block. It can be used to provide easily verified\nMerkle-proofs of the state of the application.")]),e._v(" "),n("p",[e._v("It is expected that the app will persist state to disk on Commit. The\noption to have all transactions replayed from some previous block is the\njob of the "),n("a",{attrs:{href:"#handshake"}},[e._v("Handshake")]),e._v(".")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("func (app *KVStoreApplication) Commit() types.ResponseCommit {\n\t// Using a memdb - just return the big endian size of the db\n\tappHash := make([]byte, 8)\n\tbinary.PutVarint(appHash, app.state.Size)\n\tapp.state.AppHash = appHash\n\tapp.state.Height += 1\n\tsaveState(app.state)\n\treturn types.ResponseCommit{Data: appHash}\n}\n")])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("ResponseCommit requestCommit(RequestCommit requestCommit) {\n\n    // update the internal app-state\n    byte[] newAppState = calculateAppState();\n\n    // and return it to the node\n    return ResponseCommit.newBuilder().setCode(CodeType.OK).setData(ByteString.copyFrom(newAppState)).build();\n}\n")])])]),n("h3",{attrs:{id:"beginblock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#beginblock"}}),e._v(" BeginBlock")]),e._v(" "),n("p",[e._v("The BeginBlock request can be used to run some code at the beginning of\nevery block. It also allows Tendermint to send the current block hash\nand header to the application, before it sends any of the transactions.")]),e._v(" "),n("p",[e._v("The app should remember the latest height and header (ie. from which it\nhas run a successful Commit) so that it can tell Tendermint where to\npick up from when it restarts. See information on the Handshake, below.")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// Track the block hash and header information\nfunc (app *PersistentKVStoreApplication) BeginBlock(req types.RequestBeginBlock) types.ResponseBeginBlock {\n\t// reset valset changes\n\tapp.ValUpdates = make([]types.ValidatorUpdate, 0)\n\treturn types.ResponseBeginBlock{}\n}\n")])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/*\n * all types come from protobuf definition\n */\nResponseBeginBlock requestBeginBlock(RequestBeginBlock req) {\n\n    Header header = req.getHeader();\n    byte[] prevAppHash = header.getAppHash().toByteArray();\n    long prevHeight = header.getHeight();\n    long numTxs = header.getNumTxs();\n\n    // run your pre-block logic. Maybe prepare a state snapshot, message components, etc\n\n    return ResponseBeginBlock.newBuilder().build();\n}\n")])])]),n("h3",{attrs:{id:"endblock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#endblock"}}),e._v(" EndBlock")]),e._v(" "),n("p",[e._v("The EndBlock request can be used to run some code at the end of every block.\nAdditionally, the response may contain a list of validators, which can be used\nto update the validator set. To add a new validator or update an existing one,\nsimply include them in the list returned in the EndBlock response. To remove\none, include it in the list with a "),n("code",[e._v("power")]),e._v(" equal to "),n("code",[e._v("0")]),e._v(". Validator's "),n("code",[e._v("address")]),e._v("\nfield can be left empty. Tendermint core will take care of updating the\nvalidator set. Note the change in voting power must be strictly less than 1/3\nper block if you want a light client to be able to prove the transition\nexternally. See the "),n("a",{attrs:{href:"https://godoc.org/github.com/tendermint/tendermint/lite#hdr-How_We_Track_Validators",target:"_blank",rel:"noopener noreferrer"}},[e._v("light client\ndocs"),n("OutboundLink")],1),e._v("\nfor details on how it tracks validators.")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// Update the validator set\nfunc (app *PersistentKVStoreApplication) EndBlock(req types.RequestEndBlock) types.ResponseEndBlock {\n\treturn types.ResponseEndBlock{ValidatorUpdates: app.ValUpdates}\n}\n")])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/*\n * Assume that one validator changes. The new validator has a power of 10\n */\nResponseEndBlock requestEndBlock(RequestEndBlock req) {\n    final long currentHeight = req.getHeight();\n    final byte[] validatorPubKey = getValPubKey();\n\n    ResponseEndBlock.Builder builder = ResponseEndBlock.newBuilder();\n    builder.addDiffs(1, Types.Validator.newBuilder().setPower(10L).setPubKey(ByteString.copyFrom(validatorPubKey)).build());\n\n    return builder.build();\n}\n")])])]),n("h3",{attrs:{id:"query-connection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#query-connection"}}),e._v(" Query Connection")]),e._v(" "),n("p",[e._v('This connection is used to query the application without engaging\nconsensus. It\'s exposed over the tendermint core rpc, so clients can\nquery the app without exposing a server on the app itself, but they must\nserialize each query as a single byte array. Additionally, certain\n"standardized" queries may be used to inform local decisions, for\ninstance about which peers to connect to.')]),e._v(" "),n("p",[e._v("Tendermint Core currently uses the Query connection to filter peers upon\nconnecting, according to IP address or node ID. For instance,\nreturning non-OK ABCI response to either of the following queries will\ncause Tendermint to not connect to the corresponding peer:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("p2p/filter/addr/<ip addr>")]),e._v(", where "),n("code",[e._v("<ip addr>")]),e._v(" is an IP address.")]),e._v(" "),n("li",[n("code",[e._v("p2p/filter/id/<id>")]),e._v(", where "),n("code",[e._v("<is>")]),e._v(" is the hex-encoded node ID (the hash of\nthe node's p2p pubkey).")])]),e._v(" "),n("p",[e._v("Note: these query formats are subject to change!")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('func (app *KVStoreApplication) Query(reqQuery types.RequestQuery) (resQuery types.ResponseQuery) {\n\tif reqQuery.Prove {\n\t\tvalue := app.state.db.Get(prefixKey(reqQuery.Data))\n\t\tresQuery.Index = -1 // TODO make Proof return index\n\t\tresQuery.Key = reqQuery.Data\n\t\tresQuery.Value = value\n\t\tif value != nil {\n\t\t\tresQuery.Log = "exists"\n\t\t} else {\n\t\t\tresQuery.Log = "does not exist"\n\t\t}\n\t\treturn\n\t} else {\n\t\tresQuery.Key = reqQuery.Data\n\t\tvalue := app.state.db.Get(prefixKey(reqQuery.Data))\n\t\tresQuery.Value = value\n\t\tif value != nil {\n\t\t\tresQuery.Log = "exists"\n\t\t} else {\n\t\t\tresQuery.Log = "does not exist"\n\t\t}\n\t\treturn\n\t}\n}\n')])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("    ResponseQuery requestQuery(RequestQuery req) {\n        final boolean isProveQuery = req.getProve();\n        final ResponseQuery.Builder responseBuilder = ResponseQuery.newBuilder();\n\t\tbyte[] queryData = req.getData().toByteArray();\n\n        if (isProveQuery) {\n            com.app.example.QueryResultWithProof result = generateQueryResultWithProof(queryData);\n            responseBuilder.setIndex(result.getLeftIndex());\n            responseBuilder.setKey(req.getData());\n            responseBuilder.setValue(result.getValueOrNull(0));\n            responseBuilder.setHeight(result.getHeight());\n            responseBuilder.setProof(result.getProof());\n            responseBuilder.setLog(result.getLogValue());\n        } else {\n            com.app.example.QueryResult result = generateQueryResult(queryData);\n            responseBuilder.setIndex(result.getIndex());\n            responseBuilder.setValue(result.getValue());\n            responseBuilder.setLog(result.getLogValue());\n        }\n\n        responseBuilder.setIndex(result.getIndex());\n        responseBuilder.setValue(ByteString.copyFrom(result.getValue()));\n        responseBuilder.setLog(result.getLogValue());\n    }\n\n    return responseBuilder.build();\n}\n")])])]),n("h3",{attrs:{id:"handshake"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#handshake"}}),e._v(" Handshake")]),e._v(" "),n("p",[e._v("When the app or tendermint restarts, they need to sync to a common\nheight. When an ABCI connection is first established, Tendermint will\ncall "),n("code",[e._v("Info")]),e._v(" on the Query connection. The response should contain the\nLastBlockHeight and LastBlockAppHash - the former is the last block for\nwhich the app ran Commit successfully, the latter is the response from\nthat Commit.")]),e._v(" "),n("p",[e._v("Using this information, Tendermint will determine what needs to be\nreplayed, if anything, against the app, to ensure both Tendermint and\nthe app are synced to the latest block height.")]),e._v(" "),n("p",[e._v("If the app returns a LastBlockHeight of 0, Tendermint will just replay\nall blocks.")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('func (app *KVStoreApplication) Info(req types.RequestInfo) (resInfo types.ResponseInfo) {\n\treturn types.ResponseInfo{\n\t\tData:       fmt.Sprintf("{\\"size\\":%v}", app.state.Size),\n\t\tVersion:    version.ABCIVersion,\n\t\tAppVersion: ProtocolVersion.Uint64(),\n\t}\n}\n')])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("ResponseInfo requestInfo(RequestInfo req) {\n    final byte[] lastAppHash = getLastAppHash();\n    final long lastHeight = getLastHeight();\n    return ResponseInfo.newBuilder().setLastBlockAppHash(ByteString.copyFrom(lastAppHash)).setLastBlockHeight(lastHeight).build();\n}\n")])])]),n("h3",{attrs:{id:"genesis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#genesis"}}),e._v(" Genesis")]),e._v(" "),n("p",[n("code",[e._v("InitChain")]),e._v(" will be called once upon the genesis. "),n("code",[e._v("params")]),e._v(" includes the\ninitial validator set. Later on, it may be extended to take parts of the\nconsensus params.")]),e._v(" "),n("p",[e._v("In go:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// Save the validators in the merkle tree\nfunc (app *PersistentKVStoreApplication) InitChain(req types.RequestInitChain) types.ResponseInitChain {\n\tfor _, v := range req.Validators {\n\t\tr := app.updateValidator(v)\n\t\tif r.IsErr() {\n\t\t\tapp.logger.Error("Error updating validators", "r", r)\n\t\t}\n\t}\n\treturn types.ResponseInitChain{}\n}\n')])])]),n("p",[e._v("In Java:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("/*\n * all types come from protobuf definition\n */\nResponseInitChain requestInitChain(RequestInitChain req) {\n    final int validatorsCount = req.getValidatorsCount();\n    final List<Types.Validator> validatorsList = req.getValidatorsList();\n\n    validatorsList.forEach((validator) -> {\n        long power = validator.getPower();\n        byte[] validatorPubKey = validator.getPubKey().toByteArray();\n\n        // do somehing for validator setup in app\n    });\n\n    return ResponseInitChain.newBuilder().build();\n}\n")])])])])}),[],!1,null,null,null);t.default=s.exports}}]);