(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{420:function(e,n,t){"use strict";t.r(n);var o=t(1),s=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"configuration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#configuration"}}),e._v(" Configuration")]),e._v(" "),t("p",[e._v("Tendermint Core can be configured via a TOML file in\n"),t("code",[e._v("$TMHOME/config/config.toml")]),e._v(". Some of these parameters can be overridden by\ncommand-line flags. For most users, the options in the "),t("code",[e._v("##### main base configuration options #####")]),e._v(" are intended to be modified while config options\nfurther below are intended for advance power users.")]),e._v(" "),t("h2",{attrs:{id:"options"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#options"}}),e._v(" Options")]),e._v(" "),t("p",[e._v("The default configuration file create by "),t("code",[e._v("tendermint init")]),e._v(" has all\nthe parameters set with their default values. It will look something\nlike the file below, however, double check by inspecting the\n"),t("code",[e._v("config.toml")]),e._v(" created with your version of "),t("code",[e._v("tendermint")]),e._v(" installed:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('# This is a TOML config file.\n# For more information, see https://github.com/toml-lang/toml\n\n# NOTE: Any path below can be absolute (e.g. "/var/myawesomeapp/data") or\n# relative to the home directory (e.g. "data"). The home directory is\n# "$HOME/.tendermint" by default, but could be changed via $TMHOME env variable\n# or --home cmd flag.\n\n##### main base config options #####\n\n# TCP or UNIX socket address of the ABCI application,\n# or the name of an ABCI application compiled in with the Tendermint binary\nproxy_app = "tcp://127.0.0.1:26658"\n\n# A custom human readable name for this node\nmoniker = "anonymous"\n\n# If this node is many blocks behind the tip of the chain, FastSync\n# allows them to catchup quickly by downloading blocks in parallel\n# and verifying their commits\nfast_sync = true\n\n# Database backend: goleveldb | cleveldb | boltdb\n# * goleveldb (github.com/syndtr/goleveldb - most popular implementation)\n#   - pure go\n#   - stable\n# * cleveldb (uses levigo wrapper)\n#   - fast\n#   - requires gcc\n#   - use cleveldb build tag (go build -tags cleveldb)\n# * boltdb (uses etcd\'s fork of bolt - github.com/etcd-io/bbolt)\n#   - EXPERIMENTAL\n#   - may be faster is some use-cases (random reads - indexer)\n#   - use boltdb build tag (go build -tags boltdb)\ndb_backend = "goleveldb"\n\n# Database directory\ndb_dir = "data"\n\n# Output level for logging, including package level options\nlog_level = "main:info,state:info,*:error"\n\n# Output format: \'plain\' (colored text) or \'json\'\nlog_format = "plain"\n\n##### additional base config options #####\n\n# Path to the JSON file containing the initial validator set and other meta data\ngenesis_file = "config/genesis.json"\n\n# Path to the JSON file containing the private key to use as a validator in the consensus protocol\npriv_validator_file = "config/priv_validator.json"\n\n# TCP or UNIX socket address for Tendermint to listen on for\n# connections from an external PrivValidator process\npriv_validator_laddr = ""\n\n# Path to the JSON file containing the private key to use for node authentication in the p2p protocol\nnode_key_file = "config/node_key.json"\n\n# Mechanism to connect to the ABCI application: socket | grpc\nabci = "socket"\n\n# TCP or UNIX socket address for the profiling server to listen on\nprof_laddr = ""\n\n# If true, query the ABCI app on connecting to a new peer\n# so the app can decide if we should keep the connection or not\nfilter_peers = false\n\n##### advanced configuration options #####\n\n##### rpc server configuration options #####\n[rpc]\n\n# TCP or UNIX socket address for the RPC server to listen on\nladdr = "tcp://0.0.0.0:26657"\n\n# A list of origins a cross-domain request can be executed from\n# Default value \'[]\' disables cors support\n# Use \'["*"]\' to allow any origin\ncors_allowed_origins = []\n\n# A list of methods the client is allowed to use with cross-domain requests\ncors_allowed_methods = ["HEAD", "GET", "POST"]\n\n# A list of non simple headers the client is allowed to use with cross-domain requests\ncors_allowed_headers = ["Origin", "Accept", "Content-Type", "X-Requested-With", "X-Server-Time"]\n\n# TCP or UNIX socket address for the gRPC server to listen on\n# NOTE: This server only supports /broadcast_tx_commit\ngrpc_laddr = ""\n\n# Maximum number of simultaneous connections.\n# Does not include RPC (HTTP&WebSocket) connections. See max_open_connections\n# If you want to accept a larger number than the default, make sure\n# you increase your OS limits.\n# 0 - unlimited.\n# Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}\n# 1024 - 40 - 10 - 50 = 924 = ~900\ngrpc_max_open_connections = 900\n\n# Activate unsafe RPC commands like /dial_seeds and /unsafe_flush_mempool\nunsafe = false\n\n# Maximum number of simultaneous connections (including WebSocket).\n# Does not include gRPC connections. See grpc_max_open_connections\n# If you want to accept a larger number than the default, make sure\n# you increase your OS limits.\n# 0 - unlimited.\n# Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}\n# 1024 - 40 - 10 - 50 = 924 = ~900\nmax_open_connections = 900\n\n# Maximum number of unique clientIDs that can /subscribe\n# If you\'re using /broadcast_tx_commit, set to the estimated maximum number\n# of broadcast_tx_commit calls per block.\nmax_subscription_clients = 100\n\n# Maximum number of unique queries a given client can /subscribe to\n# If you\'re using GRPC (or Local RPC client) and /broadcast_tx_commit, set to\n# the estimated # maximum number of broadcast_tx_commit calls per block.\nmax_subscriptions_per_client = 5\n\n# How long to wait for a tx to be committed during /broadcast_tx_commit.\n# WARNING: Using a value larger than 10s will result in increasing the\n# global HTTP write timeout, which applies to all connections and endpoints.\n# See https://github.com/tendermint/tendermint/issues/3435\ntimeout_broadcast_tx_commit = "10s"\n\n# Maximum size of request body, in bytes\nmax_body_bytes = {{ .RPC.MaxBodyBytes }}\n\n# Maximum size of request header, in bytes\nmax_header_bytes = {{ .RPC.MaxHeaderBytes }}\n\n# The path to a file containing certificate that is used to create the HTTPS server.\n# Migth be either absolute path or path related to tendermint\'s config directory.\n# If the certificate is signed by a certificate authority,\n# the certFile should be the concatenation of the server\'s certificate, any intermediates,\n# and the CA\'s certificate.\n# NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server. Otherwise, HTTP server is run.\ntls_cert_file = ""\n\n# The path to a file containing matching private key that is used to create the HTTPS server.\n# Migth be either absolute path or path related to tendermint\'s config directory.\n# NOTE: both tls_cert_file and tls_key_file must be present for Tendermint to create HTTPS server. Otherwise, HTTP server is run.\ntls_key_file = ""\n\n##### peer to peer configuration options #####\n[p2p]\n\n# Address to listen for incoming connections\nladdr = "tcp://0.0.0.0:26656"\n\n# Address to advertise to peers for them to dial\n# If empty, will use the same port as the laddr,\n# and will introspect on the listener or use UPnP\n# to figure out the address.\nexternal_address = ""\n\n# Comma separated list of seed nodes to connect to\nseeds = ""\n\n# Comma separated list of nodes to keep persistent connections to\npersistent_peers = ""\n\n# UPNP port forwarding\nupnp = false\n\n# Path to address book\naddr_book_file = "config/addrbook.json"\n\n# Set true for strict address routability rules\n# Set false for private or local networks\naddr_book_strict = true\n\n# Maximum number of inbound peers\nmax_num_inbound_peers = 40\n\n# Maximum number of outbound peers to connect to, excluding persistent peers\nmax_num_outbound_peers = 10\n\n# Time to wait before flushing messages out on the connection\nflush_throttle_timeout = "100ms"\n\n# Maximum size of a message packet payload, in bytes\nmax_packet_msg_payload_size = 1024\n\n# Rate at which packets can be sent, in bytes/second\nsend_rate = 5120000\n\n# Rate at which packets can be received, in bytes/second\nrecv_rate = 5120000\n\n# Set true to enable the peer-exchange reactor\npex = true\n\n# Seed mode, in which node constantly crawls the network and looks for\n# peers. If another node asks it for addresses, it responds and disconnects.\n#\n# Does not work if the peer-exchange reactor is disabled.\nseed_mode = false\n\n# Comma separated list of peer IDs to keep private (will not be gossiped to other peers)\nprivate_peer_ids = ""\n\n# Toggle to disable guard against peers connecting from the same ip.\nallow_duplicate_ip = false\n\n# Peer connection configuration.\nhandshake_timeout = "20s"\ndial_timeout = "3s"\n\n##### mempool configuration options #####\n[mempool]\n\nrecheck = true\nbroadcast = true\nwal_dir = ""\n\n# Maximum number of transactions in the mempool\nsize = 5000\n\n# Limit the total size of all txs in the mempool.\n# This only accounts for raw transactions (e.g. given 1MB transactions and\n# max_txs_bytes=5MB, mempool will only accept 5 transactions).\nmax_txs_bytes = 1073741824\n\n# Size of the cache (used to filter transactions we saw earlier) in transactions\ncache_size = 10000\n\n# Maximum size of a single transaction.\n# NOTE: the max size of a tx transmitted over the network is {max_tx_bytes} + {amino overhead}.\nmax_tx_bytes = 1048576\n\n##### fast sync configuration options #####\n[fastsync]\n\n# Fast Sync version to use:\n#   1) "v0" (default) - the legacy fast sync implementation\n#   2) "v1" - refactor of v0 version for better testability\nversion = "v0"\n\n##### consensus configuration options #####\n[consensus]\n\nwal_file = "data/cs.wal/wal"\n\ntimeout_propose = "3s"\ntimeout_propose_delta = "500ms"\ntimeout_prevote = "1s"\ntimeout_prevote_delta = "500ms"\ntimeout_precommit = "1s"\ntimeout_precommit_delta = "500ms"\ntimeout_commit = "1s"\n\n# Make progress as soon as we have all the precommits (as if TimeoutCommit = 0)\nskip_timeout_commit = false\n\n# EmptyBlocks mode and possible interval between empty blocks\ncreate_empty_blocks = true\ncreate_empty_blocks_interval = "0s"\n\n# Reactor sleep duration parameters\npeer_gossip_sleep_duration = "100ms"\npeer_query_maj23_sleep_duration = "2s"\n\n# Block time parameters. Corresponds to the minimum time increment between consecutive blocks.\nblocktime_iota = "1s"\n\n##### transactions indexer configuration options #####\n[tx_index]\n\n# What indexer to use for transactions\n#\n# Options:\n#   1) "null"\n#   2) "kv" (default) - the simplest possible indexer, backed by key-value storage (defaults to levelDB; see DBBackend).\nindexer = "kv"\n\n# Comma-separated list of tags to index (by default the only tag is "tx.hash")\n#\n# You can also index transactions by height by adding "tx.height" tag here.\n#\n# It\'s recommended to index only a subset of tags due to possible memory\n# bloat. This is, of course, depends on the indexer\'s DB and the volume of\n# transactions.\nindex_tags = ""\n\n# When set to true, tells indexer to index all tags (predefined tags:\n# "tx.hash", "tx.height" and all tags from DeliverTx responses).\n#\n# Note this may be not desirable (see the comment above). IndexTags has a\n# precedence over IndexAllTags (i.e. when given both, IndexTags will be\n# indexed).\nindex_all_tags = false\n\n##### instrumentation configuration options #####\n[instrumentation]\n\n# When true, Prometheus metrics are served under /metrics on\n# PrometheusListenAddr.\n# Check out the documentation for the list of available metrics.\nprometheus = false\n\n# Address to listen for Prometheus collector(s) connections\nprometheus_listen_addr = ":26660"\n\n# Maximum number of simultaneous connections.\n# If you want to accept a larger number than the default, make sure\n# you increase your OS limits.\n# 0 - unlimited.\nmax_open_connections = 3\n\n# Instrumentation namespace\nnamespace = "tendermint"\n')])])]),t("h2",{attrs:{id:"empty-blocks-vs-no-empty-blocks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#empty-blocks-vs-no-empty-blocks"}}),e._v(" Empty blocks VS no empty blocks")]),e._v(" "),t("p",[t("strong",[e._v("create_empty_blocks = true")])]),e._v(" "),t("p",[e._v("If "),t("code",[e._v("create_empty_blocks")]),e._v(" is set to "),t("code",[e._v("true")]),e._v(" in your config, blocks will be\ncreated ~ every second (with default consensus parameters). You can regulate\nthe delay between blocks by changing the "),t("code",[e._v("timeout_commit")]),e._v(". E.g. "),t("code",[e._v('timeout_commit = "10s"')]),e._v(" should result in ~ 10 second blocks.")]),e._v(" "),t("p",[t("strong",[e._v("create_empty_blocks = false")])]),e._v(" "),t("p",[e._v("In this setting, blocks are created when transactions received.")]),e._v(" "),t("p",[e._v("Note after the block H, Tendermint creates something we call a \"proof block\"\n(only if the application hash changed) H+1. The reason for this is to support\nproofs. If you have a transaction in block H that changes the state to X, the\nnew application hash will only be included in block H+1. If after your\ntransaction is committed, you want to get a lite-client proof for the new state\n(X), you need the new block to be committed in order to do that because the new\nblock has the new application hash for the state X. That's why we make a new\n(empty) block if the application hash changes. Otherwise, you won't be able to\nmake a proof for the new state.")]),e._v(" "),t("p",[e._v("Plus, if you set "),t("code",[e._v("create_empty_blocks_interval")]),e._v(" to something other than the\ndefault ("),t("code",[e._v("0")]),e._v("), Tendermint will be creating empty blocks even in the absence of\ntransactions every "),t("code",[e._v("create_empty_blocks_interval")]),e._v(". For instance, with\n"),t("code",[e._v("create_empty_blocks = false")]),e._v(" and "),t("code",[e._v('create_empty_blocks_interval = "30s"')]),e._v(",\nTendermint will only create blocks if there are transactions, or after waiting\n30 seconds without receiving any transactions.")]),e._v(" "),t("h2",{attrs:{id:"consensus-timeouts-explained"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#consensus-timeouts-explained"}}),e._v(" Consensus timeouts explained")]),e._v(" "),t("p",[e._v("There's a variety of information about timeouts in "),t("router-link",{attrs:{to:"/tendermint-core/running-in-production.html"}},[e._v("Running in\nproduction")])],1),e._v(" "),t("p",[e._v("You can also find more detailed technical explanation in the spec: "),t("a",{attrs:{href:"https://arxiv.org/abs/1807.04938",target:"_blank",rel:"noopener noreferrer"}},[e._v("The latest\ngossip on BFT consensus"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('[consensus]\n...\n\ntimeout_propose = "3s"\ntimeout_propose_delta = "500ms"\ntimeout_prevote = "1s"\ntimeout_prevote_delta = "500ms"\ntimeout_precommit = "1s"\ntimeout_precommit_delta = "500ms"\ntimeout_commit = "1s"\n')])])]),t("p",[e._v("Note that in a successful round, the only timeout that we absolutely wait no\nmatter what is "),t("code",[e._v("timeout_commit")]),e._v(".")]),e._v(" "),t("p",[e._v("Here's a brief summary of the timeouts:")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("timeout_propose")]),e._v(" = how long we wait for a proposal block before prevoting\nnil")]),e._v(" "),t("li",[t("code",[e._v("timeout_propose_delta")]),e._v(" = how much timeout_propose increases with each round")]),e._v(" "),t("li",[t("code",[e._v("timeout_prevote")]),e._v(" = how long we wait after receiving +2/3 prevotes for\nanything (ie. not a single block or nil)")]),e._v(" "),t("li",[t("code",[e._v("timeout_prevote_delta")]),e._v(" = how much the timeout_prevote increases with each\nround")]),e._v(" "),t("li",[t("code",[e._v("timeout_precommit")]),e._v(" = how long we wait after receiving +2/3 precommits for\nanything (ie. not a single block or nil)")]),e._v(" "),t("li",[t("code",[e._v("timeout_precommit_delta")]),e._v(" = how much the timeout_precommit increases with\neach round")]),e._v(" "),t("li",[t("code",[e._v("timeout_commit")]),e._v(" = how long we wait after committing a block, before starting\non the new height (this gives us a chance to receive some more precommits,\neven though we already have +2/3)")])])])}),[],!1,null,null,null);n.default=s.exports}}]);