(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{354:function(t,s,a){"use strict";a.r(s);var n=a(1),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"state"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state"}}),t._v(" State")]),t._v(" "),a("h2",{attrs:{id:"state-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-2"}}),t._v(" State")]),t._v(" "),a("p",[t._v("The state contains information whose cryptographic digest is included in block headers, and thus is\nnecessary for validating new blocks. For instance, the validators set and the results of\ntransactions are never included in blocks, but their Merkle roots are - the state keeps track of them.")]),t._v(" "),a("p",[t._v("Note that the "),a("code",[t._v("State")]),t._v(" object itself is an implementation detail, since it is never\nincluded in a block or gossipped over the network, and we never compute\nits hash. Thus we do not include here details of how the "),a("code",[t._v("State")]),t._v(" object is\npersisted or queried. That said, the types it contains are part of the specification, since\ntheir Merkle roots are included in blocks and their values are used in\nvalidation.")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" State "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Version     Version\n    LastResults "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Result\n    AppHash "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n\n    LastValidators "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Validator\n    Validators "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Validator\n    NextValidators "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Validator\n\n    ConsensusParams ConsensusParams\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("Note there is a hard-coded limit of 10000 validators. This is inherited from the\nlimit on the number of votes in a commit.")]),t._v(" "),a("h3",{attrs:{id:"result"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#result"}}),t._v(" Result")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Result "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Code "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint32")]),t._v("\n    Data "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("code",[t._v("Result")]),t._v(" is the result of executing a transaction against the application.\nIt returns a result code and an arbitrary byte array (ie. a return value).")]),t._v(" "),a("p",[t._v("NOTE: the Result needs to be updated to include more fields returned from\nprocessing transactions, like gas variables and tags - see\n"),a("a",{attrs:{href:"https://github.com/tendermint/tendermint/issues/1007",target:"_blank",rel:"noopener noreferrer"}},[t._v("issue 1007"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h3",{attrs:{id:"validator"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validator"}}),t._v(" Validator")]),t._v(" "),a("p",[t._v("A validator is an active participant in the consensus with a public key and a voting power.\nValidator's also contain an address field, which is a hash digest of the PubKey.")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Validator "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Address     "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v("\n    PubKey      PubKey\n    VotingPower "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("When hashing the Validator struct, the address is not included,\nbecause it is redundant with the pubkey.")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("state.Validators")]),t._v(", "),a("code",[t._v("state.LastValidators")]),t._v(", and "),a("code",[t._v("state.NextValidators")]),t._v(", must always be sorted by validator address,\nso that there is a canonical order for computing the MerkleRoot.")]),t._v(" "),a("p",[t._v("We also define a "),a("code",[t._v("TotalVotingPower")]),t._v(" function, to return the total voting power:")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("TotalVotingPower")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vals "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("Validators"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" v "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("range")]),t._v(" vals"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        sum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VotingPower\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h3",{attrs:{id:"consensusparams"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consensusparams"}}),t._v(" ConsensusParams")]),t._v(" "),a("p",[t._v("ConsensusParams define various limits for blockchain data structures.\nLike validator sets, they are set during genesis and can be updated by the application through ABCI.\nWhen hashed, only a subset of the params are included, to allow the params to\nevolve without breaking the header.")]),t._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" ConsensusParams "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tBlock\n\tEvidence\n\tValidator\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" hashedParams "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    BlockMaxBytes "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n    BlockMaxGas   "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("func")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("params ConsensusParams"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Hash")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("byte")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("SHA256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("hashedParams"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        BlockMaxBytes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" params"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MaxBytes"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n        BlockMaxGas"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" params"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Block"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MaxGas"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" BlockParams "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tMaxBytes        "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n\tMaxGas          "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n  TimeIotaMs      "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" EvidenceParams "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tMaxAge "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("int64")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" ValidatorParams "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tPubKeyTypes "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("string")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h4",{attrs:{id:"block"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#block"}}),t._v(" Block")]),t._v(" "),a("p",[t._v("The total size of a block is limited in bytes by the "),a("code",[t._v("ConsensusParams.Block.MaxBytes")]),t._v(".\nProposed blocks must be less than this size, and will be considered invalid\notherwise.")]),t._v(" "),a("p",[t._v('Blocks should additionally be limited by the amount of "gas" consumed by the\ntransactions in the block, though this is not yet implemented.')]),t._v(" "),a("p",[t._v("The minimal time between consecutive blocks is controlled by the\n"),a("code",[t._v("ConsensusParams.Block.TimeIotaMs")]),t._v(".")]),t._v(" "),a("h4",{attrs:{id:"evidence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#evidence"}}),t._v(" Evidence")]),t._v(" "),a("p",[t._v("For evidence in a block to be valid, it must satisfy:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("block.Header.Height - evidence.Height < ConsensusParams.Evidence.MaxAge\n")])])]),a("h4",{attrs:{id:"validator-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#validator-2"}}),t._v(" Validator")]),t._v(" "),a("p",[t._v("Validators from genesis file and "),a("code",[t._v("ResponseEndBlock")]),t._v(" must have pubkeys of type ∈\n"),a("code",[t._v("ConsensusParams.Validator.PubKeyTypes")]),t._v(".")])])}),[],!1,null,null,null);s.default=e.exports}}]);